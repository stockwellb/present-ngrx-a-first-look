<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    <p>unboxing</p>
                    <h1>@ngrx/store</h1>
				</section>
                <section>
                    <p>@ngrx/store</p>
                    <ul>
                        <li class="fragment">State management</li>
                        <li class="fragment">Designed for Angular</li>
                        <li class="fragment">RxJs Power</li>
                        <li class="fragment">Inspired by Redux</li>
                    </ul>
                    <aside class="notes">
                        <p>@ngrx/store is a controlled state container designed to help write performant, consistent applications on top of Angular.</p>
                        <p>Core tenets:</p>
                        <ul>
                            <li>State is a single immutable data structure.</li>
                            <li>Actions describe state changes.</li>
                            <li>Pure functions called reducers take the previous state and the next action to compute the new state.</li>
                            <li>State accessed with the Store, an observable of state and an observer of actions.</li>
                        </ul>
                    </aside>
                </section>
				<section>
					<p>What is RxJS?</p>
                    <aside class="notes">
                        <p>RxJS or Reactive Extensions for JavaScript is a library for transforming, composing, and querying streams of data.</p>
                        <ul>
                            <li>All kinds of data</li>
                            <li>Simple</li>
                            <li>Events</li>
                            <li>Complex flows of data</li>
                        </ul>
                    </aside>
				</section>
                <section>
                    <aside>
                    <blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr"><a href="https://t.co/aIQTdbFPrA">pic.twitter.com/aIQTdbFPrA</a></p>&mdash; Todd Motto (@toddmotto) <a href="https://twitter.com/toddmotto/status/687104621421158400">January 13, 2016</a></blockquote>
                    <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
                    </aside>
                </section>
                <section>
                    <p>With rxjs, everything is a stream.</p>
                </section>
				<section>
					<p>Here's an example</p>
				</section>
				<section data-background-iframe="https://embed.plnkr.co/IJikndZI4FflMWYiuBZH/" data-background-interactive>
                    </section>
                <section>
                    <p>What is Redux?</p>
                </section>
                <section>
                    <p>It's an implementation of Flux</p>
                </section>
                <section>
                    <p>Flux</p>
                    <img src="flux-800x167.png">
                    <p>An application architecture</p>
                </section>
                <section>
                    <p>@ngrx/store</p>
                    <aside class="notes">
                        <p>@ngrx/store is an RxJS powered state management for Angular applications, inspired by Redux.</p>
                    </aside>
                </section>
                <section>
                    <p>Action</p>
                    <pre>
                        <code data-trim data-noescape>
import { Action } from '@ngrx/store';
import { SomeThing } from '../models';

export const ADD_SOME_THING = '[SomeThing] Add';
export class AddSomeThingAction implements Action {
  readonly type = ADD_SOME_THING;

  constructor(public payload: SomeThing) { }
}
                        </code>
                    </pre>
                    <aside class="notes">
                        <p>The action is general a type and a payload</p>
                    </aside>
                </section>
                <section>
                    <p>Dispatcher</p>
                    <pre><code data-trim data-noescape>
@Component({
      selector: 'some-thing-page',
      template: 'some-thing.html'
    export class CollectionPageComponent {
      someThing: Observable;

      constructor(store: Store) {
        this.someThing = store.dispatch(
            new AddSomeThingAction(
                models.SomeThing.Create()));
      }
    }
                    </code></pre>
                    <aside class="notes">
                        <p>The dispatcher will be called from a component</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
export interface State {
  ids: string[];
  entities: { [id: string]: SomeThing };
};

export const initialState: State = {
  ids: [],
  entities: {},
};
                        </code>
                    </pre>
                    <p>state</p>
                    <aside class="notes">
                        <p>State is established in the store. Generally in the reducer</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
export function reducer(state = initialState, action: Actions): State {
  switch (action.type) {
    case ADD_SOME_THING: {
      //build new state
    }

    default: {
      return state;
    }
  }
}
                        </code>
                    </pre>
                    <p>reducer</p>
                    <aside class="notes">
                        <p>the reducer takes the existing state, an action and returns a new state</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
const items = [action.payload].filter(thing => {
                return !state.entities[thing.id]
                });
const ids = items.map(q => q.id);

const newEntities = [action.payload].reduce(
(entities: { [id: string]: Thing }, thing: Thing) => {
  return Object.assign(entities, {
      [thing.id]: thing
  });
}, {});

                        </code>
                    </pre>
                    <p>immutable state</p>
                    <aside class="notes">
                        <p>This is hand rolled immutability. We could use a library like immutable.js</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
return {
  ids: [...state.ids, ...ids],
  entities: Object.assign({}, state.entities, newEntities),
}
                        </code>
                    </pre>
                    <p>reducers return new state</p>
                    <aside class="notes">
                        <p>Once again the reducer return the new state</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
export const getThingsState = (state: State) => {
    return state.things;
};

export const getSelectedThing =
  createSelector(getThingState, fromThings.getSelected);

                        </code>
                    </pre>
                    <p>selectors</p>
                    <aside class="notes">
                        <p>Selectors can be nested/composed. Here we're using the Reselect library.
                        The idea is that selectors can be composed and only recomputed if
                        their result has changed since the last time they where called. The === operator
                        give us this power with immutable state. Like a snowball rolling down hill,
                        reducers accumulate value through iteration...</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
const reducers = {
    things: fromThings.reducer,
    otherThings: fromOther.reducer
};

const mainReducer: ActionReducer = combineReducers(reducers);


export function reducer(state: any, action: any) {
    return mainReducer(state, action);
}
                        </code>
                    </pre>
                    <p>combining reducers</p>
                    <aside class="notes">
                        <p>Reducers are combined into one reducer that will be passed into @ngrx/store.</p>
                    </aside>
                </section>
                <section>
                    <p>Store</p>
                    <pre>
                        <code>
import { StoreModule } from '@ngrx/store';
import { reducer } from '../reducers'

@NgModule({
    declarations: [],
    imports: [
        StoreModule.provideStore(reducer),
    ],
    bootstrap: [],
    entryComponents: [],
    providers: []
})
                        </code>
                    </pre>
                    <p>configuration</p>
                    <aside class="notes">
                        <p>Here we pass our top level reducer into the store module.</p>
                    </aside>
                </section>
                <section>
                    <p>State management strategies</p>
                    <ul>
                    <li class="fragment">Data should be normalized.</li>
                    <li class="fragment">i.e., Only store an object once. Reference it's id.</li>
                    <li class="fragment">Usually one reducer per type.</li>
                    <li class="fragment">Avoid arrays for object collections.</li>
                    <li class="fragment">
                        <pre>
                            <code>
ids: [1, 2, 3],
entities: {
    1: {id: 1, name='one'},
    2: {id: 2, name='two'},
    3: {id: 3, name='three'},
}
                            </code>
                        </pre>
                    </li>
                    </ul>
                    <aside class="notes">
                        <p>state design is VERY important</p>
                    </aside>
                </section>
                <section>
                    <p>Questions</p>
                    <p class="fragment">Remember, I'm a @ngrx/store noob.</p>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                transition: 'slide',
                parallaxBackgroundImage: 'parallax.jpg',

                // Parallax background size
                parallaxBackgroundSize: '3840px 1200px',

                dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
